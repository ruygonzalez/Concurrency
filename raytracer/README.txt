
Since some rays are more computationally demanding than others, not all ray tracing computations take an equal amount of time. Therefore if you split the number of rays in half and assign half to one thread and half to another (or split them up more if NTHREADS > 2), one thread may take longer than the other and thus the whole process takes longer since it's limited by the thread that takes longer (since the other thread can't help out once it's finished with its rays).

Therefore it's better to have something similat to a producer-consumer queue where you have a vector/list/some sort of data structure with rays to trace (the producer) and threads to remove a ray from the list and trace it then take another ray and trace it and keep doing this until all the rays are traced (with the threads being the consumers). This way the threads are continously tracing a ray until all the rays are traced and you split evenly by computational time required rather than by number of rays. 
